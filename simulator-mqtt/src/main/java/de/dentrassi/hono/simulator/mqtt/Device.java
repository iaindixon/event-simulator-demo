package de.dentrassi.hono.simulator.mqtt;

import static de.dentrassi.hono.demo.common.Register.shouldRegister;

import java.util.Random;
import java.util.concurrent.atomic.AtomicLong;

import de.dentrassi.hono.demo.common.Register;
import io.netty.handler.codec.mqtt.MqttConnectReturnCode;
import io.netty.handler.codec.mqtt.MqttQoS;
import io.vertx.core.Vertx;
import io.vertx.core.buffer.Buffer;
import io.vertx.mqtt.MqttClient;
import io.vertx.mqtt.MqttClientOptions;
import io.vertx.mqtt.MqttConnectionException;

public class Device {

    private final MqttClient client;

    private final Buffer payload;

    private final Vertx vertx;

    private final String topic;

    private final Register register;

    private final String deviceId;

    private final String username;

    private final String password;

    private boolean connected;

    private static final String HONO_MQTT_HOST = System.getenv().getOrDefault("HONO_MQTT_HOST", "localhost");
    private static final int HONO_MQTT_PORT = Application.envOrElse("HONO_MQTT_PORT", Integer::parseInt, 1883);
    private static final boolean HONO_MQTT_SSL = Application.envOrElse("HONO_MQTT_SSL", Boolean::parseBoolean, false);
    private static final boolean HONO_MQTT_TRUST_ALL = Application.envOrElse("HONO_MQTT_TRUST_ALL",
            Boolean::parseBoolean,
            false);

    private static final boolean AUTO_REGISTER = Boolean
            .parseBoolean(System.getenv().getOrDefault("AUTO_REGISTER", "true"));

    private static final long RECONNECT_DELAY = Application.envOrElse("RECONNECT_DELAY", Long::parseLong, 2_000L);
    private static final int RECONNECT_JITTER = Application.envOrElse("RECONNECT_JITTER", Integer::parseInt, 2_000);

    private final Random random = new Random();

    public static final AtomicLong TICKED = new AtomicLong();
    public static final AtomicLong SENT = new AtomicLong();
    public static final AtomicLong CONNECTED = new AtomicLong();

    public Device(final Vertx vertx, final String username, final String deviceId, final String tenant,
            final String password, final Register register) {

        this.vertx = vertx;
        this.register = register;
        this.topic = "telemetry";

        this.deviceId = deviceId;
        this.username = username;
        this.password = password;

        this.payload = Buffer.factory.buffer("{foo: 42}");

        final MqttClientOptions options = new MqttClientOptions();

        options.setCleanSession(true);
        options.setConnectTimeout(10_000);
        options.setAutoGeneratedClientId(true);
        options.setSsl(HONO_MQTT_SSL);
        options.setTrustAll(HONO_MQTT_TRUST_ALL);
        options.setKeepAliveTimeSeconds(10);
        options.setAutoKeepAlive(true);

        options.setUsername(username + "@" + tenant);
        options.setPassword(password);

        this.client = MqttClient.create(vertx, options);

        this.client.closeHandler(v -> connectionLost(null));

        startConnect();
    }

    private void startConnect() {

        this.vertx.setTimer(getConnectDelay(), v -> {

            this.client.connect(HONO_MQTT_PORT, HONO_MQTT_HOST, HONO_MQTT_HOST, connected -> {
                if (connected.failed()) {
                    connectionLost(connected.cause());
                } else {
                    connectionEstablished();
                }
            });
        });

    }

    private long getConnectDelay() {

        final long delay = RECONNECT_DELAY + this.random.nextInt(RECONNECT_JITTER);
        if (delay <= 0) {
            return 1;
        }
        return delay;
    }

    public void tick() {
        this.vertx.runOnContext(v -> {
            doPublish();
        });
    }

    private void doPublish() {

        TICKED.incrementAndGet();

        if (!this.client.isConnected()) {
            return;
        }

        SENT.incrementAndGet();

        this.client.publish(this.topic, this.payload, MqttQoS.AT_MOST_ONCE, false, false);
    }

    private void connectionEstablished() {
        if (!this.connected) {
            this.connected = true;
            CONNECTED.incrementAndGet();
        }
    }

    protected void connectionLost(final Throwable throwable) {
        if (this.connected) {
            this.connected = false;
            CONNECTED.decrementAndGet();
        }

        if (throwable instanceof MqttConnectionException) {
            final MqttConnectReturnCode code = ((MqttConnectionException) throwable).code();

            switch (code) {
            case CONNECTION_REFUSED_BAD_USER_NAME_OR_PASSWORD:
                //$FALL-THROUGH$
            case CONNECTION_REFUSED_NOT_AUTHORIZED:
                //$FALL-THROUGH$
            case CONNECTION_REFUSED_IDENTIFIER_REJECTED:
                register();
                break;
            default:
                break;
            }
        } else {
            if (throwable != null) {
                throwable.printStackTrace();
            }
        }

        startConnect();
    }

    private void register() {
        if (AUTO_REGISTER && shouldRegister()) {
            try {
                this.register.device(this.deviceId, this.username, this.password);
            } catch (final Exception e) {
            }
        }
    }

}
